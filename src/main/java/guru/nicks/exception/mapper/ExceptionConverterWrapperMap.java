package guru.nicks.exception.mapper;

import guru.nicks.designpattern.SubclassBeforeSuperclassMap;
import guru.nicks.exception.BusinessException;
import guru.nicks.exception.ExceptionConverter;

/**
 * Keys are exception classes (hierarchy roots), values are their mappers (wrappers that accept plain {@link Throwable},
 * for convenience). Key order is the same as in {@link ExceptionConverterMap}.
 */
public class ExceptionConverterWrapperMap
        extends SubclassBeforeSuperclassMap<Throwable, ExceptionConverter<Throwable, ? extends BusinessException>> {

    /**
     * Creates wrappers for {@code converters}.
     *
     * @param converters exception converters
     */
    public static ExceptionConverterWrapperMap of(ExceptionConverterMap converters) {
        var map = new ExceptionConverterWrapperMap();
        converters.forEach((exceptionClass, exceptionConverter) ->
                map.put(exceptionClass, generalizeExceptionConverter(exceptionConverter)));
        return map;
    }

    /**
     * Creates {@link ExceptionConverter} which accepts <b>any</b> exception, but under the hood assumes it's {@code S}.
     * The idea is to catch {@link Throwable}, find out its real class ({@code S}) in the map, and invoke the matching
     * converter.
     * <p>
     * Subclassing the original converter doesn't always work because it may be auto-generated. ByteBuddy is unable to
     * intercept methods in autogenerated subclasses: it fails with 'Class definition not found'.
     *
     * @param converter exception converter
     * @param <S>       source exception type
     * @param <T>       target exception type
     * @return function which accepts {@link Exception} and checks for {@code exceptionClass} in runtime
     */
    private static <S extends Throwable, T extends BusinessException
            > ExceptionConverter<Throwable, T> generalizeExceptionConverter(ExceptionConverter<S, T> converter) {
        return new ExceptionConverter<>() {
            @SuppressWarnings("unchecked")
            @Override
            public T convert(Throwable cause) {
                return converter.convert((S) cause);
            }
        };
    }

}
